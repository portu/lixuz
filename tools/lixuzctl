#!/usr/bin/perl
# LIXUZ content management system
# Copyright (C) Utrop A/S Portu media & Communications 2012
# Copyright (C) Eskild Hustvedt 2012
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
use strict;
use warnings;
use 5.010;
use File::Temp qw(tempdir);
use File::Copy qw(copy);
use File::Path qw(mkpath);
use File::Find qw(find);
use File::Basename qw(basename dirname);
use Getopt::Long;
use Cwd qw(realpath);
use Config::Any;
use JSON qw(encode_json decode_json);
use Try::Tiny;
use constant (
    true => 1,
    false => 0
);
my $verbosity                = 0;
# The revision of the data format that we write
my $dataFormatRevision       = 1;
# The minimum supported api level of plumbing commands
my $minSupportedApiLevel     = 2;
# The real (latest) supported api level of plumbing commands
my $currentSupportedApiLevel = 4;
my $logOut;
my $logfile;
my $lixuzDir;
my @pluginMetaFiles = qw(plugin.yml triggers.pl COPYING README);
# Boolean flag, set to true once LIXUZ:: modules have been loaded
# to avoid loading them multiple times.
my $loadedModules;

main();

# Purpose: Handles toplevel commands and hands off control to the various
# subsections
sub main
{
    Getopt::Long::Configure('pass_through','permute');

    GetOptions(
        'v|verbose' => sub {
            $verbosity++
        },
        'debug' => sub {
            $verbosity = 99;
        },
        'logfile=s' => sub {
            shift;
            $logfile = shift;
            open($logOut,'>>',$logfile) or die('Failed to open logfile: '.$!."\n");
        },
        'quiet' => sub {
            $verbosity = -1;
        },
        'lixuzdir=s' => sub {
            shift;
            $lixuzDir = shift;
        },
        # This is not used anywhere yet, but it is supported for use later
        # (and already supplied by the upgrade script)
        'lixuz-upgrade' => sub {},
        # This is not used anywhere yet, but is supported for use later
        # (and is already supplied by us when using selfRun)
        'chained' => sub {},
    );
    
    $lixuzDir //= realpath(dirname(realpath($0)).'/../');
    if (!-d $lixuzDir)
    {
        die($lixuzDir.': does not exist'."\n");
    }
    outLog('Lixuz directory: '.$lixuzDir);
    unshift(@INC,$lixuzDir.'/lib');
    my $action = shift(@ARGV);

    if (!defined $action || $action eq '--help' || $action eq '-h')
    {
        usage(0);
    }

    given($action)
    {
        when(/^plugins?$/)
        {
            plugins();
        }

        when('database')
        {
            database();
        }

        when('plumbing')
        {
            plumbing();
        }

        default
        {
            die('Unknown command: '.$action."\nSee --help for more information\n");
        }
    }
}

# Purpose: Print formatted --help output
# Usage: printHelp('-shortoption', '--longoption', 'description');
#  Description will be reformatted to fit within a normal terminal
sub printHelp
{
	# The short option
	my $short = shift,
	# The long option
	my $long = shift;
	# The description
	my $desc = shift;
	# The generated description that will be printed in the end
	my $GeneratedDesc;
	# The current line of the description
	my $currdesc = '';
	# The maximum length any line can be
	my $maxlen = 80;
	# The length the options take up
	my $optionlen = 20;
	# Check if the short/long are LONGER than optionlen, if so, we need
	# to do some additional magic to take up only $maxlen.
	# The +1 here is because we always add a space between them, no matter what
	if ((length($short) + length($long) + 1) > $optionlen)
	{
		$optionlen = length($short) + length($long) + 1;
	}
	# Split the description into lines
	foreach my $part (split(/ /,$desc))
	{
		if(defined $GeneratedDesc)
		{
			if ((length($currdesc) + length($part) + 1 + 24) > $maxlen)
			{
				$GeneratedDesc .= "\n";
				$currdesc = '';
			}
			else
			{
				$currdesc .= ' ';
				$GeneratedDesc .= ' ';
			}
		}
		$currdesc .= $part;
		$GeneratedDesc .= $part;
	}
	# Something went wrong
	die('Option mismatch') if not $GeneratedDesc;
	# Print it all
	foreach my $description (split(/\n/,$GeneratedDesc))
	{
		printf "%-4s %-19s %s\n", $short,$long,$description;
		# Set short and long to '' to ensure we don't print the options twice
		$short = '';$long = '';
	}
	# Succeed
	return true;
}

# Purpose: Run the subroutine provided if --help or -h was provided *anywhere*
# on the command-line, OR if there are no parameters left in @ARGV
# Usage: checkForHelpParam(sub { } );
sub checkForHelpParam
{
    my $sub = shift;
    if (scalar(@ARGV) == 0)
    {
        $sub->();
    }
    else
    {
        foreach my $e (@ARGV)
        {
            if ($e eq '-h' || $e eq '--help')
            {
                $sub->();
            }
        }
    }
}

# Purpose: Displays toplevel usage information
sub usage
{
    print "USAGE: lixuzctl [category] [subcommand] [parameters]\n";
    print "\n";
    print "Available categories:\n";
    printHelp('','plugins','Plugin actions (install, remove, upgrade, list etc.)');
    printHelp('','database','Database actions (upgrade)');
    printHelp('','plumbing','Plumbing actions, used internally by Lixuz (not meant for public use)');
    print "\n";
    print "Run: \"lixuzctl [category] --help\" for a list of subcommands and parameters\n";
    print "for that category\n";
    exit(shift);
}

# Purpose: Reads and parses our meta file and returns it
sub loadMetaFile
{
    my $metaFile;
    if (-e $lixuzDir.'/.lixuzctl.data')
    {
        $metaFile = decode_json(slurp($lixuzDir.'/.lixuzctl.data'));
    }
    $metaFile //= {};
    $metaFile->{formatRevision} //= 1;
    $metaFile->{lastWritten} //= time,
    $metaFile->{plugins} //= {};

    if ($metaFile->{formatRevision} != $dataFormatRevision)
    {
        die("ERROR: Unknown .lixuzctl.data format revision: ".$metaFile->{formatRevision}."\n");
    }
    return $metaFile;
}

# Purpose: Writes the supplied datastructure to our meta file
sub writeMetaFile
{
    my $metaFile = shift;
    $metaFile->{lastWritten} = time;
    $metaFile->{formatRevision} = $dataFormatRevision;
    $metaFile->{lastAPI} = $currentSupportedApiLevel.'/'.$minSupportedApiLevel.'/'.$dataFormatRevision;
    open(my $out,'>',$lixuzDir.'/.lixuzctl.data');
    print {$out} encode_json($metaFile);
    close($out);
}

# Purpose: Reads the entire contents of a file and returns it
sub slurp
{
    my $file = shift;
    open(my $in,'<',$file) or die("Failed to open $file for reading: $!\n");
    local $/ = undef;
    my $data = <$in>;
    close($in);
    return $data;
}

# Purpose: Reads a YML file, parses it and returns the datastructure
sub readYML
{
    my $file = shift;
    my $data = Config::Any->load_files({ files => [ $file ], use_ext => 1});
    $data = $data->[0]->{$file};
    return $data;
}

# Purpose: Check if a directory is empty
# Usage: DirIsEmpty(PATH);
#  Returns 1 if it is empty, 0 if it isn't.
sub DirIsEmpty
{
    my $dir = shift;
    return 0 if not $dir;
    return 0 if not -d $dir;
    opendir(TESTDIR, $dir);
    my @TestDir = readdir(TESTDIR);
    closedir(TESTDIR);
    if(not scalar @TestDir > 2)
    {
        return 1;
    }
    return 0;
}

# Purpose: Log some action
# Usage: outLog(String);
sub outLog
{
    my $msg = shift;
    if ($verbosity > 0)
    {
        print $msg."\n";
    }
    if ($logOut)
    {
        print {$logOut} '[lixuzctl] '.$msg."\n";
    }
}

# Purpose: Output something when not in silent mode
# Usage: same as print
sub printv
{
    if($verbosity > -1)
    {
        print @_;
    }
}

# Purpose: Output something when in debug mode
# Usage: printd('text')
# Adds a newline to each message and a debug prefix
sub printd
{
    if ($verbosity >= 99)
    {
        print 'Debug: ';
        print @_;
        print "\n";
    }
}

# Purpose: Load LIXUZ:: namespaced modules
sub loadLixuzModules
{
    if ($loadedModules)
    {
        return;
    }
    printd('Loading LIXUZ:: namespace dependencies');
    unshift(@INC,$lixuzDir.'/lib');
    # FIXME: Improved errors
    eval('use LIXUZ::HelperModules::Scripts qw(getDBIC getConfig fakeC);1;') or die;
    eval('use LIXUZ::HelperModules::Templates qw(parse_templatefile);1') or die;
    printd('Dependencies loaded');
    $loadedModules = 1;
}

# ---
# Database functions
# ---

# Purpose: Handler for database-section subcommands
sub database
{
    checkForHelpParam(sub { usageDatabase(0) });

    my $subcommand = shift(@ARGV);


    given($subcommand)
    {

        when('upgrade')
        {
            chdir($lixuzDir.'/sql');
            exec('./upgradeDB','../lixuz.yml');
        }

        default
        {
            die('Unknown subcommand for database: '.$subcommand."\nSee \"database --help\" for more information\n");
        }
    }
}

# Purpose: Displays usage information for database subcommands
sub usageDatabase
{
    print "USAGE: lixuzctl database [subcommand] [parameters]\n";
    print "\n";
    print "Available subcommands:\n";
    printHelp('','upgrade','Upgrade the database to the latest schema revision');
    exit(shift);
}

# ---
# Generic package functions
# ---

# Purpose: Handler for plugins-section subcommands
sub plugins
{
    checkForHelpParam(sub { usagePlugins(0) });

    my $subcommand = shift(@ARGV);

    printv('Operating on Lixuz at '.$lixuzDir."\n");

    given($subcommand)
    {
        when('watch')
        {
            my $dir = shift // '.';
            printv('Watching '.$dir.' for changes'."\n");
            while(1)
            {
                if(system(qw(inotifywait -q -q -e modify -e create -e delete -e moved_to),'--excludei','\.(ipp|swp)$','--excludei','~$','-r',$dir.'/') != 0)
                {
                    return;
                }
                my $package = buildPackage('build',$dir);
                installPackage('upgrade',$package);
            }
        }

        when('buildinstall')
        {
            my $package = buildPackage('build',shift(@ARGV));
            installPackage('upgrade',$package);
        }

        when('install')
        {
            foreach (@ARGV)
            {
                installPackage('install',$_);
            }
        }

        when('remove')
        {
            foreach (@ARGV)
            {
                removePackage($_);
            }
        }

        when('upgrade')
        {
            foreach (@ARGV)
            {
                installPackage('upgrade',$_);
            }
        }

        when('list')
        {
            listPackages();
        }

        when('listfiles')
        {
            listPluginFiles();
        }

        when('build')
        {
            buildPackage($subcommand,@ARGV);
        }

        when('reconstruct')
        {
            while(@ARGV)
            {
                my $package = shift(@ARGV);
                my $targetDir = shift(@ARGV);
                reconstructPackage($package,$targetDir);
            }
        }

        when('owner')
        {
            checkPackageOwners('output',@ARGV);
        }

        when('create')
        {
            createPluginTree(@ARGV);
        }

        default
        {
            die('Unknown subcommand for plugins: '.$subcommand."\nSee \"plugins --help\" for more information\n");
        }
    }
}

# Purpose: Displays usage information for plugins subcommands
sub usagePlugins
{
    print "USAGE: lixuzctl plugins [subcommand] [parameters]\n";
    print "\n";
    print "Available subcommands:\n";
    printHelp('','install X','Install a new plugin package, located at X');
    printHelp('','remove X','Remove the plugin X');
    printHelp('','upgrade X','Upgrade a plugin using the package located at X');
    printHelp('','build X?','Build a plugin package using data at X (where X defaults to ./)');
    printHelp('','buildinstall X','Runs build X, and then installs the package generated');
    printHelp('','owner X Y ..','Output which plugin (if any) owns the files specified');
    printHelp('','listfiles','List all files installed by plugins, along with which plugin installed the file');
    printHelp('','watch X','Runs buildinstall X whenever a file in the plugins subdirectory changes');
    printHelp('','reconstruct X Y','Reconstruct a plugin package from an installed plugin (X), saving the package to Y');
    printHelp('','create X','Create a new plugin named "X" in ./X');
    exit(shift);
}

# Purpose: Executes package installation triggers
sub runPackageTrigger
{
    my $package = shift;
    my $trigger = shift;

    my $file;
    if ($trigger eq 'build')
    {
        $file = shift;
    }
    else
    {
        $file = $lixuzDir.'/.pluginMeta/'.$package.'/triggers.pl';
    }
    if (-e $file)
    {
        outLog('Running trigger '.$trigger.' in '.$file);
        my $ns = ($package =~ s/-//g);
        $ns = 'CtlTriggers::'.$package.'::r'.time.'::'.int(rand(9999999));
        try
        {
            eval('package '.$ns.';'.slurp($file).'; if ($triggers->{"'.$trigger.'"}) { $triggers->{"'.$trigger.'"}->(); };1;') or die($@);
        }
        catch
        {
            warn('Warning: '.$trigger.' trigger for '.$package.' failed: '.$_."\n");
        };
    }
    else
    {
        outLog('Skipping trigger '.$trigger.' because '.$file.' does not exist');
    }
}

# Purpose: Check owners
sub checkPackageOwners
{
    my $mode = shift;
    if (scalar(@_) == 0)
    {
        die('Missing parameters: Which files to check ownership of'."\n");
    }
    foreach my $checkFile (@_)
    {
        my $meta = loadMetaFile();
        my $file = realpath($checkFile);
        my $owner;
        foreach my $plugin (keys %{$meta->{plugins}})
        {
            foreach my $pkgFile (@{$meta->{plugins}->{$plugin}->{files}})
            {
                if ($file eq realpath($lixuzDir.'/'.$pkgFile))
                {
                    $owner = $plugin;
                    last;
                }
            }
            last if $owner;
        }
        if ($mode eq 'output')
        {
            if ($owner)
            {
                print "$checkFile is owned by $owner\n";
            }
            else
            {
                print "$checkFile is not owned by any plugin\n";
            }
        }
        elsif($mode eq 'plumbing')
        {
            if (!$owner)
            {
                exit(1);
            }
        }
    }
}

# Purpose: List all installed plugin files
sub listPluginFiles
{
    my $meta = loadMetaFile();
    if (%{$meta->{plugins}})
    {
        foreach my $plugin (keys %{$meta->{plugins}})
        {
            foreach my $pkgFile (@{$meta->{plugins}->{$plugin}->{files}})
            {
                print "$plugin: $pkgFile\n";
            }
        }
    }
    else
    {
        print '(there are no plugins installed)'."\n";
    }
}

# Purpose: Create a new plugin tree
sub createPluginTree
{
    my $path = shift;
    if (!defined $path)
    {
        die('Usage: lixuzctl plugins create NAME'."\n");
    }
    if (-e $path)
    {
        die($path.': already exists');
    }

    mkdir($path);

    open(my $yml,'>',$path.'/plugin.yml');
    print {$yml} '# Lixuz plugin metadata'."\n\n";
    print {$yml} '# Plugin name'."\n";
    print {$yml} 'name: '.$path."\n";
    print {$yml} '# Plugin version number'."\n";
    print {$yml} 'version: 0.1'."\n";
    print {$yml} '# The lowest Lixuz API version supported'."\n";
    print {$yml} 'apiversion: 1'."\n";
    print {$yml} '# A short description of the plugin'."\n";
    print {$yml} 'description: I did not edit plugin.yml'."\n";
    print {$yml} '# The license of the plugin'."\n";
    print {$yml} 'license: GPLv3'."\n";
    print {$yml} '# A YAML list of file paths that should be treated as live templates.'."\n";
    print {$yml} '# They will be installed as a live template in Lixuz, and will'."\n";
    print {$yml} '# not be installed into the Lixuz tree (may be left empty)'."\n";
    print {$yml} '# Note: liveTemplates are still treated as part of the plugin, and'."\n";
    print {$yml} '#       will be removed if the plugin is removed.'."\n";
    print {$yml} 'liveTemplates:'."\n";
    close($yml);
    print 'Create: '.$path.'/plugin.yml'."\n";

    open(my $triggers,'>',$path.'/triggers.pl');
    print {$triggers} 'use strict;
use warnings;
use 5.010;
use LIXUZ::HelperModules::Scripts qw(getDBIC);

my $triggers = {
    # Triggered on plugin upgrade
    upgrade => sub {
    },
    # Triggered on plugin install
    install => sub {
    },
    # Triggered on plugin removal
    removal => sub {
    },
    # Triggered on a Lixuz upgrade
    lixuzUpgrade => sub {
    },
    # Triggered during build of the plugin
    build => sub
    {
    },
};';
    close($triggers);
    print 'Create: '.$path.'/triggers.pl'."\n";

    mkdir($path.'/plugin');
    foreach my $sub (qw(lib root))
    {
        mkdir($path.'/plugin/'.$sub);
        print 'Create: '.$path.'/plugin/'.$sub."\n";
    }
    exit(0);
}

# ---
# Package construction functions
# ---

# Purpose: Builds a new Lixuz plugin package
sub buildPackage
{
    my $mode = shift;
    my $srcdir = shift;
    $srcdir //= '.';
    my $target = shift;
    $target //= '.';
    my $disableTriggers = shift;

    printv('Performing package sanity checks...');
    if (! -w $target && -w $srcdir)
    {
        warn($target.'/ is not writeable, saving package to '.$srcdir."\n");
        $target = $srcdir;
    }
    elsif(! -w $target)
    {
        die('Neither '.$target.'/ or '.$srcdir.' is writeable, giving up'."\n");
    }

    if (! -e $srcdir.'/plugin.yml')
    {
        die($srcdir.'/plugin.yml is missing'."\n");
    }

    my $meta = Config::Any->load_files({ files => [ $srcdir.'/plugin.yml' ], use_ext => 1});
    $meta = $meta->[0]->{$srcdir.'/plugin.yml'};

    foreach my $setting (qw(name version apiversion license))
    {
        if (!defined $meta->{$setting} || !length($meta->{$setting}))
        {
            die('Required setting "'.$setting.'" missing from plugin.yml'."\n");
        }
    }

    my $pluginName = getPluginSystemName($meta);
    printv('done'."\n");

    if (!$disableTriggers)
    {
        printv('Running build triggers...');
        runPackageTrigger($pluginName,'build',$srcdir.'/triggers.pl');
        printv('done'."\n");
    }

    printv('Constructing package...');
    my $fname = $pluginName.'-'.$meta->{version}.'.lpp';
    $fname =~ s/\s+/-/g;

    my $dir = tempdir( CLEANUP => 1, TEMPLATE => 'lixuzctl-buildpkg.XXXXXXX');
    mkpath($dir.'/lzplugin/');
    $dir = $dir.'/lzplugin/';

    foreach my $copy (@pluginMetaFiles)
    {
        if (-e $srcdir.'/'.$copy)
        {
            copy($srcdir.'/'.$copy,$dir);
        }
    }

    if (! -d $srcdir.'/plugin')
    {
        die($srcdir.'/plugin does not exist. Cowardly refusing to create empty package'."\n");
    }

    find({ 
            no_chdir => 1,
            wanted => sub
            {
                my $path = substr($_,length($srcdir));
                return if /(\.swp|~)$/;
                if (-d $_)
                {
                    mkpath($dir.'/'.$path);
                }
                else
                {
                    copy($_,$dir.'/'.$path);
                }
            },
        }, $srcdir.'/plugin');
    my $targetFile = $target.'/'.$fname;
    $targetFile =~ s{/+}{/}g;
    system('tar','-C',$dir.'/..','-cf',$targetFile,'./lzplugin');
    printv('done'."\n");
    printv('Wrote package to '.realpath($targetFile)."\n");
    return realpath($targetFile);
}

# Purpose: Reconstructs an installed Lixuz plugin package
sub reconstructPackage
{
    my $pluginName = shift;
    my $targetDir = shift;
    my $meta = loadMetaFile();

    if(! $meta->{plugins}->{$pluginName})
    {
        die($pluginName.': is not installed, unable to reconstruct package'."\n");
    }

    printv('Reconstructing '.$pluginName.'... ');

    my $dir = tempdir( CLEANUP => 1, TEMPLATE => 'lixuzctl-reconstructpkg.XXXXXXX');
    mkpath($dir.'/plugin/');

    foreach my $meta (@{$meta->{plugins}->{$pluginName}->{metaFiles}})
    {
        copy($lixuzDir.'/.pluginMeta/'.$pluginName.'/'.$meta,$dir);
    }
    foreach my $file (@{$meta->{plugins}->{$pluginName}->{files}})
    {
        mkpath($dir.'/plugin/'.dirname($file));
        copy($lixuzDir.'/'.$file,$dir.'/plugin/'.dirname($file));
    }

    buildPackage('reconstruct',$dir,$targetDir,1);
}

# ---
# Package management functions
# ---

# Purpose: Generate a "system name" (normalized name) from a package meta-file
sub getPluginSystemName
{
    my $meta = shift;
    my $pluginName = $meta->{name};
    $pluginName =~ s/ /-/g;
    $pluginName = lc($pluginName);
    return $pluginName;
}

# Purpose: Installs or upgrades a Lixuz plugin package
sub installPackage
{
    my $mode = shift;
    my $package = shift;
    $package = realpath($package);
    if (! -e $package)
    {
        die($package.': does not exist'."\n");
    }
    my $meta = loadMetaFile();

    my $dir = tempdir( CLEANUP => 1, TEMPLATE => 'lixuzctl-installpkg.XXXXXXX');
    system('tar','-C',$dir,'-xf',$package);
    if (! -d $dir.'/lzplugin' || ! -e $dir.'/lzplugin/plugin.yml')
    {
        die($package.': does not appear to be a Lixuz plugin package'."\n");
    }
    $dir = $dir.'/lzplugin/';

    my $pluginMeta = readYML($dir.'/plugin.yml');
    my $pluginName = getPluginSystemName($pluginMeta);
    $| = 1;
    if($mode eq 'install' && defined $meta->{plugins}->{$pluginName})
    {
        warn($pluginName.': was already installed, assuming you wanted to upgrade instead.'."\n");
        $mode = 'upgrade';
    }
    elsif($mode eq 'upgrade' && ! $meta->{plugins}->{$pluginName})
    {
        warn($pluginName.': is not installed, assuming you wanted to install instead.'."\n");
        $mode = 'install';
    }
    my $action = 'Installing';
    if ($mode eq 'upgrade')
    {
        $action = 'Upgrading';
    }
    elsif($mode eq 'reinject')
    {
        $action = 'Re-injecting';
    }
    printv($action.' '.$pluginMeta->{name}.' '.$pluginMeta->{version}.' ['.basename($package).']...');
    my @copy;
    my %upgradeMap;
    if ($mode eq 'upgrade' || $mode eq 'reinject')
    {
        foreach my $file (@{ $meta->{plugins}->{$pluginName}->{files} })
        {
            $upgradeMap{$file} = 1;
        }
    }

    find({ 
            no_chdir => 1,
            wanted => sub
            {
                my $path = substr($_,length($dir.'/plugin'));
                if (!-d $_ && !/~$/ && !/\.swp$/)
                {
                    if (-e $lixuzDir.'/'.$path && !$upgradeMap{$path})
                    {
                        $path =~ s{^/}{};
                        if ($mode eq 'upgrade')
                        {
                            die("failed\n".$path.': already exists in Lixuz tree and does not belong to this plugin.'."\n".'Refusing to overwrite.'."\n");
                        }
                        elsif($mode ne 'reinject')
                        {
                            die("failed\n".$path.': already exists in Lixuz tree. Refusing to overwrite.'."\n");
                        }
                    }
                    delete($upgradeMap{$path});
                    push(@copy,$path);
                }
            },
        }, $dir.'/plugin');
    printv('.');
    foreach my $f (@copy)
    {
        mkpath($lixuzDir.'/'.dirname($f));
        copy($dir.'/plugin/'.$f,$lixuzDir.'/'.$f) or die('Failed to copy '.$f.' from package: '.$!."\n");
    }
    printv('.');
    my @metaFiles;
    mkpath($lixuzDir.'/.pluginMeta/'.$pluginName);
    if ($mode eq 'upgrade' || $mode eq 'reinject')
    {
        printv('.');
        foreach my $oldFile (keys %upgradeMap)
        {
            unlink($lixuzDir.'/'.$oldFile);
        }
        printv('.');
        foreach my $oldFile (@{ $meta->{plugins}->{$pluginName}->{metaFiles} })
        {
            unlink($lixuzDir.'/.pluginMeta/'.$pluginName.'/'.$oldFile);
        }
    }
    foreach my $copy (@pluginMetaFiles)
    {
        if (-e $dir.'/'.$copy)
        {
            push(@metaFiles,$copy);
            copy($dir.'/'.$copy,$lixuzDir.'/.pluginMeta/'.$pluginName);
        }
    }
    if ($mode eq 'upgrade' || $mode eq 'reinject')
    {
        printv('.');
        foreach my $oldFile (keys %upgradeMap)
        {
            unlink($lixuzDir.'/'.$oldFile);
            my $checkDir = $lixuzDir.'/'.$oldFile;
            while($checkDir = dirname($checkDir))
            {
                if (!DirIsEmpty($checkDir))
                {
                    last;
                }
                rmdir($checkDir);
            }
        }
    }
    if (-d $lixuzDir.'/.git')
    {
        my $excludes = slurp($lixuzDir.'/.git/info/exclude');
        my %files = map { $_ => 1 } split(/\n/,$excludes);
        my @append;
        foreach my $file (@copy)
        {
            if (!$files{$file})
            {
                push(@append,$file);
            }
        }
        if (@append)
        {
            open(my $out,'>>',$lixuzDir.'/.git/info/exclude');
            foreach my $file (@append)
            {
                print {$out} '# Added by lixuzctl for plugin '.$pluginName."\n";
                print {$out} $file."\n";
            }
            close($out);
        }
    }
    $meta->{plugins}->{$pluginName}->{meta} = $pluginMeta;
    $meta->{plugins}->{$pluginName}->{files} = \@copy;
    $meta->{plugins}->{$pluginName}->{metaFiles} = \@metaFiles;
    $meta->{plugins}->{$pluginName}->{lastModified} = time;
    if ($mode eq 'install')
    {
        $meta->{plugins}->{$pluginName}->{installed} = time;
        runPackageTrigger($pluginName,'install');
    }
    elsif ($mode eq 'reinject')
    {
        runPackageTrigger($pluginName,'lixuzUpgrade');
    }
    elsif($mode eq 'upgrade')
    {
        runPackageTrigger($pluginName,'upgrade');
    }
    else
    {
        outLog('Not running post-"install" triggers, unknown mode: '.$mode);
    }
    writeMetaFile($meta);
    printv("done\n");
}

# Purpose: Removes a Lixuz plugin package
sub removePackage 
{
    my $pluginName = shift;
    my $meta = loadMetaFile();

    if(! $meta->{plugins}->{$pluginName})
    {
        die($pluginName.': is not installed, unable to remove package'."\n");
    }

    printv('Removing '.$pluginName.'... ');

    runPackageTrigger($pluginName,'removal');

    foreach my $meta (@{$meta->{plugins}->{$pluginName}->{metaFiles}})
    {
        unlink($lixuzDir.'/.pluginMeta/'.$pluginName.'/'.$meta);
    }
    foreach my $file (@{$meta->{plugins}->{$pluginName}->{files}})
    {
        unlink($lixuzDir.'/'.$file);
    }
    delete($meta->{plugins}->{$pluginName});
    writeMetaFile($meta);
    printv('done'."\n");
}

# Purpose: Lists all installed Lixuz plugin packages
sub listPackages
{
    my $meta = loadMetaFile();
    if (%{$meta->{plugins}})
    {
        my $fmt = '%-30s %-6s'."\n";
        printf($fmt,'Name','Version');
        foreach my $p (keys %{$meta->{plugins}})
        {
            printf($fmt,$p,$meta->{plugins}->{$p}->{meta}->{version});
        }
    }
    else
    {
        print '(there are no plugins installed)'."\n";
    }
}

# Purpose: Install a live template from a package into Lixuz
sub installTemplateFile
{
    my $file = shift;

    my $errorPrefix = 'Unable to install template from '.$file.':';

    loadLixuzModules();

    printd('Fetching DBIC');
    my $dbic = getDBIC();

    printd('Fetching a fake $c');
    my $fakeC = fakeC();

    printd('Loading config');
    my $config = getConfig();

    printd('Parsing '.$file);
    my $info = parse_templatefile($fakeC,$file);

    printd('Validating infoblock in '.$file);

    if(not defined $info or not (keys %{$info}))
    {
        die($errorPrefix.' invalid infoblock');
    }

    # TODO: Add some regexes to validate the content of the items as well,
    # UNIQUEID in particular, which should probably only be [A-Za-z0-9.-\+]
    foreach my $required (qw(VERSION NAME APIVERSION UNIQUEID TYPE))
    {
        if(not defined $info->{'TEMPLATE_'.$required} or not length($info->{'TEMPLATE_'.$required}))
        {
            die($errorPrefix.' TEMPLATE_'.$required.' missing from infoblock');
        }
    }

    if ($info->{'TEMPLATE_APIVERSION'} ne '1')
    {
        die($errorPrefix.' APIVERSION not supported. This version of Lixuz only supports APIVERSION 1, this template is for APIVERSION '.$info->{'TEMPLATE_APIVERSION'});
    }

    # When we have reached this point we can assume that all is o.k. with the
    # template and that its infoblock is well formed, and can thus simply be
    # shoved into the database without further validation.
    my $template = $dbic->resultset('LzTemplate')->find({
            uniqueid => $info->{TEMPLATE_UNIQUEID}
        });

    if(defined $template)
    {
        printd('Upgrading template from '.$file);
    }
    else
    {
        printd('Installing new template from '.$file);
        $template = $dbic->resultset('LzTemplate')->create({
                uniqueid => $info->{TEMPLATE_UNIQUEID},
            });
    }

    eval
    {
        my $name;
        $template->set_column('type',$info->{TEMPLATE_TYPE});
        $template->set_column('apiversion',1);
        if ($info->{TEMPLATE_NAME})
        {
            $name = $info->{TEMPLATE_NAME};
        }
        else
        {
            $name = $info->{TEMPLATE_UNIQUEID};
        }
        $template->set_column('name',$name);
        $template->update();
        1;
    } or do {
        my $e = $@;
        # Delete if something at all got added
        eval { if ($template) { $template->delete(); } };

        die($errorPrefix.' Failed to create template object during injection. Error: '.$e);
    };

    my $fnam = $template->template_id.'_'.$template->uniqueid.'_'.$template->apiversion.'.lz.mas';
    $template->set_column('file',$fnam);
    my $current = $dbic->resultset('LzTemplate')->search({ is_default => 1, type => $template->type });
    if (!$current || !$current->count >0)
    {
        $template->set_column('is_default',1);
    }
    $template->update();

    my $error;
    copy($file,$config->{LIXUZ}->{template_path}.'/'.$fnam) or $error = $!;

    if ($error)
    {
        $template->delete;
        die($errorPrefix.' Failed to copy file into place: '.$error);
    }
    printd('Template '.$file.' injection complete');
}

# Purpose: Remove a live template from a package from Lixuz
sub removeTemplate
{
    my $id = shift;
    my $errorPrefix = 'Failed to remove template with ID '.$id.':';
    loadLixuzModules();

    printd('Fetching DBIC');
    my $dbic = getDBIC();

    printd('Fetching a fake $c');
    my $fakeC = fakeC();

    printd('Loading config');
    my $config = getConfig();

    my $template = $dbic->resultset('LzTemplate')->find({
            uniqueid => $id,
        });

    if (! $template)
    {
        printd('No template with the ID '.$id.' in the database. Ignoring request.');
        return;
    }
    my $file = $config->{LIXUZ}->{template_path}.'/'.$template->get_column('file');
    unlink($file) or die($errorPrefix.': Failed to unlink '.$file.': '.$!."\n");
    printd('Removed '.$file);
    $template->delete;
    printd('Removed database entry');
}

# ---
# Plumbing functions
# ---
# Purpose: Handler for plumbing-section subcommands
sub plumbing
{
    my $subcommand = $ARGV[0];

    if ($verbosity < 99)
    {
        $verbosity = -1;
    }

    # These are used internally, for enforcing an api compatibility layer if
    # required. In most cases the caller is responsible for handling the
    # compatibility layer.
    if (defined($subcommand) && $subcommand =~ s/^v(\d+)/$1/)
    {
        my $levelNo = int($subcommand);
        if ($levelNo > $currentSupportedApiLevel)
        {
            die('ERROR: UNKNOWN API LEVEL: '.$subcommand."\n");
        }
        elsif($levelNo < $minSupportedApiLevel)
        {
            die('ERROR: TOO OLD API LEVEL: '.$subcommand."\n");
        }
        shift(@ARGV);
        $subcommand = $ARGV[0];
    }
    elsif(defined($subcommand) && $subcommand eq 'getlevel')
    {
        print "$currentSupportedApiLevel/$minSupportedApiLevel/$dataFormatRevision\n";
        exit(0);
    }

    checkForHelpParam(sub { usagePlumbing(0) });
    shift(@ARGV);

    given($subcommand)
    {

        when('packup')
        {
            my $dir = shift(@ARGV);
            my $meta = loadMetaFile();
            if ($meta->{plugins} && scalar(%{$meta->{plugins}}))
            {
                foreach my $p (keys %{$meta->{plugins}})
                {
                    selfRun('plugins','reconstruct',$p,$dir);
                }
            }
            else
            {
                exit(1);
            }
        }
        when('reinject')
        {
            foreach my $pkg (@ARGV)
            {
                if (-e $pkg)
                {
                    installPackage('reinject',$pkg);
                }
            }
        }

        when('templateinject')
        {
            foreach my $templateFile (@ARGV)
            {
                if (-e $templateFile)
                {
                    installTemplateFile($templateFile);
                }
            }
        }

        when('templateremove')
        {
            foreach my $templateID (@ARGV)
            {
                removeTemplate($templateID);
            }
        }

        when('checkowner')
        {
            checkPackageOwners('plumbing',@ARGV);
        }

        default
        {
            die('Unknown subcommand for plumbing: '.$subcommand."\n");
        }
    }
}

# Purpose: Displays usage information for plumbing subcommands
sub usagePlumbing
{
    print "USAGE: lixuzctl plumbing [subcommand] [parameters]\n";
    print "\n";
    print "WARNING: Plumbing commands can be potentionally dangerous.\n";
    print "Use with care.\n";
    print "\n";
    print "These commands are not meant for public use. They may have backwards-incompatible\n";
    print "changes between versions, and any command may be removed at any time\n";
    print "\n";
    print "Available subcommands:\n";
    printHelp('','packup X','Reconstruct a dump of all packages into X');
    printHelp('','reinject X Y ..','Re-inject the packages specified into the Lixuz tree (similar to an upgrade, but runs lixuzUpgrade instead of upgrade triggers, and ignores all conflicts)');
    printHelp('','checkowner X Y ..','Check if files X, Y, .. are owned by a plugin. Exits with exit status 0 if all the files are owned by plugins, 1 if not');
    printHelp('','getlevel','Output the plumbing API level supported by this version of lixuzctl');
    printHelp('','templateinject X','Install or upgrade the supplied live template file');
    printHelp('','templateremove X','Remove the template identified by the supplied unique ID X');
    exit(shift);
}

# Purpose: Run self with the correct parameters
# Usage: selfRun(options);
sub selfRun
{
    my @command = ($0,'--lixuzdir',$lixuzDir,'--chained');
    if ($verbosity == -1)
    {
        push(@command,'--quiet');
    }
    elsif($verbosity > 0)
    {
        push(@command,'--verbose');
    }
    if ($verbosity >= 99)
    {
        push(@command,'--debug');
    }
    if ($logfile)
    {
        push(@command,'--logfile',$logfile);
    }
    printd('Running self: '.join(' ',@command,@_));
    return system(@command,@_);
}
